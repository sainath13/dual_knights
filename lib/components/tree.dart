import 'dart:math';

import 'package:dual_knights/components/anti_player.dart';
import 'package:dual_knights/components/player.dart';
import 'package:dual_knights/dual_knights.dart';
import 'package:flame/collisions.dart';
import 'package:flame/components.dart';

import 'dart:developer' as developer;

import 'package:flutter/material.dart';


enum TreeState {
  idle,
  shaking,
  cutedDown,
  ahead,
  behind,
}

enum KnightRangeStatus{
  behind,
  ahead,
  notNear,
}

class Tree extends SpriteAnimationComponent with HasGameRef<DualKnights>, CollisionCallbacks {
  static const double frameWidth = 192;
  static const double frameHeight = 192;
  static const double gridSize = 64.0;  
  late final Player player;
  late final AntiPlayer antiPlayer;
  late final Map<TreeState, SpriteAnimation> animations;
  TreeState currentState = TreeState.idle;
  Vector2 currentPosition = Vector2.zero();
  
  
  Tree({required Vector2 position}) : super(size: Vector2(frameWidth, frameHeight), priority: 10) {
    this.position = position;
    currentPosition = position.clone();
  }

  @override
  Future<void> onLoad() async {
    player = game.player;
    antiPlayer = game.antiPlayer;
    final spriteSheet = await gameRef.images.load('Resources/Trees/Tree.png');
    
    // Load all animations
    animations = {
      TreeState.idle: SpriteAnimation.fromFrameData(
        spriteSheet,
        SpriteAnimationData.sequenced(
          amount: 4,
          textureSize: Vector2(frameWidth, frameHeight),
          stepTime: 0.1,
          loop: true,
          texturePosition: Vector2(0, 0),
        ),
      ),
      TreeState.shaking: SpriteAnimation.fromFrameData(
        spriteSheet,
        SpriteAnimationData.sequenced(
          amount: 2,
          textureSize: Vector2(frameWidth, frameHeight),
          stepTime: 0.1,
          loop: false,
          texturePosition: Vector2(0, frameHeight),
        ),
      ),
      TreeState.cutedDown: SpriteAnimation.fromFrameData(
        spriteSheet,
        SpriteAnimationData.sequenced(
          amount: 1,
          textureSize: Vector2(frameWidth, frameHeight),
          stepTime: 0.1,
          loop: true,
          texturePosition: Vector2(0, frameHeight * 2),
        ),
      ),
    };
    
    animation = animations[TreeState.idle];

  }

  //Generated By AWS Q!!
  KnightRangeStatus getKnightPositionRelativeToTree(Vector2 treePos, Vector2 playerPos) {
  // Define the grid size
  const double gridSize = 64.0;
  // Check if player is within range first
  double distanceX = (playerPos.x - treePos.x).abs();
  double distanceY = (playerPos.y - treePos.y).abs();
  // developer.log("playerPos: $playerPos, treePos: $treePos");
  // developer.log("Distance X: $distanceX, Distance Y: $distanceY");
  if(playerPos.x == treePos.x && playerPos.y - treePos.y == 64) {
    developer.log("Player is ahead the tree at bottom");
    return KnightRangeStatus.ahead;
  }

  if(playerPos.x == treePos.x && treePos.y - playerPos.y <= 128) {
    developer.log("Player is behind the tree at top");
    return KnightRangeStatus.behind;
  }

  if (distanceX > gridSize || distanceY > gridSize) {
    return KnightRangeStatus.notNear;
  }
  // Check for ahead positions (same y as tree, one grid left or right)
  if (playerPos.y == treePos.y) {
    if (playerPos.x == treePos.x - gridSize || playerPos.x == treePos.x + gridSize) {
      return KnightRangeStatus.ahead;
    }
  }
  // Check for behind positions (above the tree)
  if (playerPos.y <= treePos.y - gridSize && 
      playerPos.y >= treePos.y - (2 * gridSize) &&
      playerPos.x >= treePos.x - gridSize && 
      playerPos.x <= treePos.x + gridSize) {
    return KnightRangeStatus.behind;
  }
  
  return KnightRangeStatus.notNear;
}

  KnightRangeResult getKnightRangeResult(String? knight) {
    // Some logic to determine if the knight is behind the tree
    // developer.log("Player Position: ${player.position}");
    // developer.log("AntiPlayer Position: ${antiPlayer.position} "
    // "Tree Position: ${position + Vector2(0, 48)}");
    Vector2 treePosition = position + Vector2(0, 48);
    KnightRangeStatus status = KnightRangeStatus.notNear;
    if(knight == "player") {
      status = getKnightPositionRelativeToTree(treePosition, player.position);
      developer.log("Status: ${status.toString()}");
      return KnightRangeResult(status, triggeredBy: "player");
    }
    else if(knight == "antiPlayer") {
      // developer.log("Checking for AntiPlayer");
      status =  getKnightPositionRelativeToTree(treePosition, antiPlayer.position);
      //if Knight is behind
      // developer.log("Status: $status");
      return KnightRangeResult(status, triggeredBy: "antiPlayer");
    }
    //if Knight is behind
    // return KnightRangeResult(playerStatus, triggeredBy: "player");
    return KnightRangeResult(status, triggeredBy: "antiPlayer");
  }

  
  void _updateState() {
    if (currentState == TreeState.cutedDown) return;

    TreeState newState = currentState;    
    List<KnightRangeResult> knightRangeResults = [getKnightRangeResult("player"), getKnightRangeResult("antiPlayer")];
    for(KnightRangeResult knightRangeResult in knightRangeResults){
      // developer.log("Checking for knightRangeResult: ${knightRangeResult.triggeredBy}");
      KnightRangeStatus knightRangeStatus = knightRangeResult.status;
      if (knightRangeStatus == KnightRangeStatus.behind) {
        // developer.log("Behind tree");
        if(knightRangeResult.triggeredBy == "player") {
          // developer.log("Setting player priority to 5");
          player.priority = 5;
        }
        else {
          // developer.log("Setting antiplayer priority");
          antiPlayer.priority = 5;
        }
      }
      else if (knightRangeStatus == KnightRangeStatus.ahead) {
        // developer.log("Ahead of tree");
        if(knightRangeResult.triggeredBy == "player") {
          // developer.log("Done settig player.priority to 15 where as my proirity is ${priority}");
          player.priority = 15;
        }
        else {
          // developer.log("Done settig Antiplayer.priority to 15 where as my proirity is ${priority}");
          antiPlayer.priority = 15;
        }
      }
      else {
        // developer.log("Not near tree so default priority");
        player.priority = 5;
        antiPlayer.priority = 5;
      }
    }
    if (animationTicker?.isLastFrame ?? false) {
        switch (currentState) {
          case TreeState.idle:
            break;

          case TreeState.shaking:
            break;

          case TreeState.cutedDown:
            animationTicker?.reset();
            break;

          default:
            break;
        }
        return;
      }
    }
  
  @override
  void update(double dt) {
    super.update(dt);
    _updateState();
  }
}


class KnightRangeResult {
  final KnightRangeStatus status;
  final String? triggeredBy;

  KnightRangeResult(this.status, {this.triggeredBy});
}

import 'dart:math';

import 'package:dual_knights/components/anti_player.dart';
import 'package:dual_knights/components/player.dart';
import 'package:dual_knights/dual_knights.dart';
import 'package:flame/collisions.dart';
import 'package:flame/components.dart';

import 'dart:developer' as developer;

import 'package:flutter/material.dart';


enum TreeState {
  idle,
  shaking,
  cutedDown,
  ahead,
  behind,
}

enum KnightRangeStatus{
  behind,
  ahead,
  notNear,
}

class Tree extends SpriteAnimationComponent with HasGameRef<DualKnights>, CollisionCallbacks {
  static const double frameWidth = 192;
  static const double frameHeight = 192;
  static const double gridSize = 64.0;  
  late final Player player;
  late final AntiPlayer antiPlayer;
  late final Map<TreeState, SpriteAnimation> animations;
  TreeState currentState = TreeState.idle;
  Vector2 currentPosition = Vector2.zero();
  
  
  Tree({required Vector2 position}) : super(size: Vector2(frameWidth, frameHeight)) {
    this.position = position;
    currentPosition = position.clone();
  }

  @override
  Future<void> onLoad() async {
    player = game.player;
    antiPlayer = game.antiPlayer;
    final spriteSheet = await gameRef.images.load('Resources/Trees/Tree.png');
    
    // Load all animations
    animations = {
      TreeState.idle: SpriteAnimation.fromFrameData(
        spriteSheet,
        SpriteAnimationData.sequenced(
          amount: 4,
          textureSize: Vector2(frameWidth, frameHeight),
          stepTime: 0.1,
          loop: true,
          texturePosition: Vector2(0, 0),
        ),
      ),
      TreeState.shaking: SpriteAnimation.fromFrameData(
        spriteSheet,
        SpriteAnimationData.sequenced(
          amount: 2,
          textureSize: Vector2(frameWidth, frameHeight),
          stepTime: 0.1,
          loop: false,
          texturePosition: Vector2(0, frameHeight),
        ),
      ),
      TreeState.cutedDown: SpriteAnimation.fromFrameData(
        spriteSheet,
        SpriteAnimationData.sequenced(
          amount: 1,
          textureSize: Vector2(frameWidth, frameHeight),
          stepTime: 0.1,
          loop: true,
          texturePosition: Vector2(0, frameHeight * 2),
        ),
      ),
    };
    
    animation = animations[TreeState.idle];

  }
  
  bool isPlayerInRange(double playerDistanceX, double playerDistanceY) {
    return playerDistanceX <= gridSize && playerDistanceY <= gridSize;
  }

  //Generated By AWS Q!!
  KnightRangeStatus getKnightPositionRelativeToTree(Vector2 treePos, Vector2 playerPos) {
  // Define the grid size
  const double gridSize = 64.0;
  // Check if player is within range first
  double distanceX = (playerPos.x - treePos.x).abs();
  double distanceY = (playerPos.y - treePos.y).abs();
  // If player is too far, return notNear
  if (distanceX > gridSize || distanceY > gridSize) {
    return KnightRangeStatus.notNear;
  }
  // Check for ahead positions (same y as tree, one grid left or right)
  if (playerPos.y == treePos.y) {
    if (playerPos.x == treePos.x - gridSize || playerPos.x == treePos.x + gridSize) {
      return KnightRangeStatus.ahead;
    }
  }
  // Check for behind positions (above the tree)
  if (playerPos.y <= treePos.y - gridSize && 
      playerPos.y >= treePos.y - (2 * gridSize) &&
      playerPos.x >= treePos.x - gridSize && 
      playerPos.x <= treePos.x + gridSize) {
    return KnightRangeStatus.behind;
  }
  
  return KnightRangeStatus.notNear;
}

  KnightRangeResult getKnightRangeResult() {
    // Some logic to determine if the knight is behind the tree
    // developer.log("Player Position: ${player.position}");
    // developer.log("AntiPlayer Position: ${antiPlayer.position} "
    // "Tree Position: ${position + Vector2(0, 48)}");
    Vector2 treePosition = position + Vector2(0, 48);
    KnightRangeStatus playerStatus = getKnightPositionRelativeToTree(treePosition, player.position);
    KnightRangeStatus antiPlayerStatus =  getKnightPositionRelativeToTree(treePosition, antiPlayer.position);
    //if Knight is behind
    // return KnightRangeResult(playerStatus, triggeredBy: "player");
    return KnightRangeResult(antiPlayerStatus, triggeredBy: "antiPlayer");
  }

  
  void _updateState() {
    if (currentState == TreeState.cutedDown) return;

    TreeState newState = currentState;
    KnightRangeResult knightRangeResult = getKnightRangeResult();
    KnightRangeStatus knightRangeStatus = knightRangeResult.status;
    
    if (knightRangeStatus == KnightRangeStatus.behind) {
      // developer.log("Behind tree");
      if(knightRangeResult.triggeredBy == "player") {
        player.priority = 1;
      }
      else {
        // developer.log("Setting antiplayer priority");
        antiPlayer.priority = 1;
      }
    }
    else if (knightRangeStatus == KnightRangeStatus.ahead) {
      // developer.log("Ahead of tree");
      if(knightRangeResult.triggeredBy == "player") {
        player.priority = 10;
      }
      else {
        antiPlayer.priority = 10;
      }
    }
    else {
      // developer.log("Not near tree");
      player.priority = 0;
      antiPlayer.priority = 0;
    }
    if (animationTicker?.isLastFrame ?? false) {
        switch (currentState) {
          case TreeState.idle:
            break;

          case TreeState.shaking:
            break;

          case TreeState.cutedDown:
            animationTicker?.reset();
            break;

          default:
            break;
        }
        return;
      }
    }
  
  @override
  void update(double dt) {
    super.update(dt);
    _updateState();
  }
}


class KnightRangeResult {
  final KnightRangeStatus status;
  final String? triggeredBy;

  KnightRangeResult(this.status, {this.triggeredBy});
}
